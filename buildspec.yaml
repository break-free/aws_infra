# resource
# https://www.padok.fr/en/blog/codepipeline-eks-helm

version: 0.2

env:
  variables:
    PROJECT_NAME: "rdtf"
    #TODO: add list of users
    USERS: "arn:aws:iam::146452989591:user/Han.Tu"
    # run AWS.exe by 
    # & $env:AWSCLI
    AWSCLI: 'C:\Program Files\Amazon\AWSCLI\bin\aws.exe'
  #parameter-store:
     # key: "value"
     # key: "value"
  #secrets-manager:
     # key: secret-id:json-key:version-stage:version-id
     # key: secret-id:json-key:version-stage:version-id
  #exported-variables:
     # - variable
     # - variable
  #git-credential-helper: yes

phases:
  install: # Install Chocolatey, AWS CLI, Terraform, Kubectl
    commands:
      # Chocolatey 
      - "Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))"
      # AWS CLI, Terraform, Kubectl
      - choco install -yvf terraform kubernetes-cli
      - choco upgrade -yvf awscli --version 1.18.6 # AWS build server contains 1.14.x, which predates EKS, and this choco installs breaks with AWSCLI 2+, so we're stuck with one of the last 1.x
      - set PATH "%PATH%;C:\Program Files\Amazon\AWSCLI\bin"; refreshenv # manually set PATH for AWSCLI 
  pre_build:
    commands:
  build:
    commands:
    
      # Remote backend
      - set-location remote-backend
      - terraform init -input=false
      # check for pre-exiting storage and DynamoDB; add to current TF instance 
      - if( & $AWSCLI s3api list-buckets --query "Buckets[].Name" | select-string -Pattern "`"$PROJECT_NAME-state`"") {terraform import aws_s3_bucket.tf-state-storage $PROJECT_NAME-state}
      - if( & $AWSCLI s3api list-buckets --query "Buckets[].Name" | select-string -Pattern "`"$PROJECT_NAME-app-state`"") {terraform import aws_s3_bucket.tf-state-storage-app $PROJECT_NAME-app-state}
      - if( & $AWSCLI dynamodb list-tables --query "TableNames[*]" | select-string -Pattern "`"$PROJECT_NAME-state-lock`"") {terraform import aws_dynamodb_table.dynamodb-terraform-state-lock $PROJECT_NAME-state-lock}
      - if( & $AWSCLI dynamodb list-tables --query "TableNames[*]" | select-string -Pattern "`"$PROJECT_NAME-state-lock-app`"") {terraform import aws_dynamodb_table.dynamodb-terraform-state-lock-app $PROJECT_NAME-state-lock-app}
      #run TF for backend
      - .\backend_setup.ps1 $PROJECT_NAME $env:AWS_REGION
      - terraform plan -out=tfplan -input=false
      - terraform apply -input=false tfplan
      
      # EKS
      - set-location ..\eks\terraform
      # run TF for EKS
      - .\terraform_setup.ps1 $PROJECT_NAME $env:AWS_REGION
      - terraform init -input=false
      - terraform plan -out=tfplan -input=false
      - terraform apply -input=false tfplan
      ## point kubectl to eks
      - "& $AWSCLI eks --region $env:AWS_REGION update-kubeconfig --name $PROJECT_NAME"
      ## config EKS permissions
      - terraform output config_map_aws_auth > config_map_aws_auth.yaml
      # Shove in user mapping
      - $MAP_USER = get-content .\map_user.yaml; $USERS = $USERS.split("/")
      - $MAP_USER -replace "<arn>", $USERS[0] -replace "<user>", $USERS[1] >> .\config_map_aws_auth.yaml
      ## join node and add permissions
      - kubectl apply -f config_map_aws_auth.yaml
      
      # app
      - set-location ..\..\app
      #! TODO - confirm usage
      - .\app_setup.ps1 $PROJECT_NAME $env:AWS_REGION

      - terraform init -input=false
      - terraform plan -out=tfplan -input=false
      - terraform apply -input=false tfplan
      - write-host "[INFO] site URL:`n`n$(terraform output hostname)`n"
  #post_build:
    #commands: 
#reports:
  #report-name-or-arn:
    #files:
      # - location
      # - location
    #base-directory: location
    #discard-paths: yes
    #file-format: JunitXml | CucumberJson
#artifacts:
  #files:
    # - location
    # - location
  #name: $(date +%Y-%m-%d)
  #discard-paths: yes
  #base-directory: location
#cache:
  #paths:
    # - paths